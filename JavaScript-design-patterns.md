# 设计模式

### 定义

>在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。
>使用名称，使用工具。

### 原则

>找出程序变化的部分，并将变化封装起来。
>再正确的场景下，使用正确的模式。
>分辨模式的关键是意图而不是结构。

### 多态

同一个操作作用在不同的对象上，可以产生不同的解释和不同的执行结果。

### 封装

>通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离出来。
使得对象内部的细节对外部不可见。

### 委托

将对象某个行为让其他对象执行。

### JavaScript中的原型继承

>如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型。
>

### 闭包


延续局部变量的寿命

```js
    var report = function(src) {
        var img =  new Image();// 在一些低版本的浏览器中因为img 是函数的局部变量，由于函数在执行后会销毁局部变量，请求丢失。
        img.src = src; 
    }
    report('http://xxx.com')
```

### 命令模式

>将请求封装成对象，从而分离请求的发起者和请求的执行者。
43页

### 用JavaScript实现面向切面编程

AOP指的是将一些业务无关的功能抽离出来。

JavaScript天生可以使用高阶函数，通过动态织人的方式可以实现AOP

### 单例模式 

>保证一个类只有一个实例并提供一个访问它的全局访问点

```js
    //创建单例
    function singleton(fn) {
      var ob = null;  
      return function() {
          return ob || (ob = fn.apply.(this, arguments));
      }
    }
```

###策略模式

>定义一系列的算法(广义上是一系列目的相同的方法)，把它们一个个封装起来，并且可以使它们互相替换。


将执行策略和执行环境分离。
一系列的策略对象都有各个同一的目的。

```js
  eventType = {
    'click': function() {

    },
    'submit': function() {

    }
  }

  triggerEvent = function(type) {
        return eventType[type] && eventType[type]();
  } 

```

### 代理模式
>保护代理 控制不同权限的对象对目标对象的访问。
>虚拟代理 处理一些开销较大的操作。
>缓存代理 用一个类保存本体行为的结果。

1.代理和本体接口一致。
>用户可以放心地请求代理，他只关心是否能够得到想要的结果
>在任何使用本体的地方都可以替换成代理。

2.虚拟代理常见使用场景

+ 图片加载，请求合并，dom操作合并，缓存ajax请求的数据。

```
```

### 迭代器模式

>javascript ben

### 发布订阅模式 

>定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
>一是在时间上进行解耦，二是在对象之间进行解耦。
>订阅者会消耗一定的时间和内存，对象之间的必要联系被深埋在背后，导致程序难以维护和和理解。

### 命令模式

命令模式中的命令指的是一个执行某些特定事情的指令。
有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

命令队列
计算机科学里的宏（Macro)，是一种批量批处理的称谓。

### 组合模式

>描述对象部分-整体层次结构。
>利用对象的多态性，统一对待组合对象和单个对象。

### 模板模式

>抽象类
>抽象过程
>hook
>好莱坞原则

注：更加倾向于过程的统一

### 享元模式
>将大量相似对象转换成享元对象的属性，从而减少对象数量，提高性能。

### 池化操作

### 职责链模式

>更多着重于传递的特性。
>解耦了请求单个发起者和多个接收者的复杂关系。

### 中介者模式

>解除对象和对象时间的紧耦合关系。所有对象通过中介者对象来通信。

注：相对于发布订阅模式而言，中介者更倾向于对各个对象状态的统一管理。
注：将多对多的关系模式转换成一对多的关系模式。

### 装饰者模式

>在不改变对象本身的情况下，给对象动态地添加职责。

注：装饰类有点1 + 1 = 2 的概念。
注：有点像包装函数的感觉。
注：装饰者模式更注重于动态组装。

### 状态模式

>将状态分装成状态类，然后将一个对象的状态分装在对象内部，通过状态的切换改变状态。（这是是传统面向对象的处理方式）。
>一般而言if else 的确能解决大部分的问题，且不导致程序难以维护，但是当状态数量过多或者状态之间的转换路径不是唯一的时候，代码中将充斥着大量的if else 判断。

注：用状态的转移取代条件语句的判断。
注：这里提到了状态机的概念，当前状态和条件能确定下个状态的时候（有限状态机）则可以通过构造二维数组实现状态转移。
注：因为上下文可以切换，我们可以将一系列的状态类转化成状态机的属性。

### 适配器模式

### 单一职责原则(SRP) single responsibility principle

>一个对象（方法）只做一件事。
>职责是一个动机，是对一个完整的变化部分的一个抽象。（具体抽象到那个层次需要相关经验来把握）
> 

注：对于同时变化的职责，不必要将他们分开。
注：职责的变化轴仅当它们确定会发生变化时才具有意义，即使两个职责被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动去分离它们，在代码需要重构的时候再分离也不迟。
注：SRP原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于单元测试。当一个职责的变更不会影响其他的职责。
注：SRP会增加这些对象之间相互联系的难度。

### 最少知识原则(LKP)

>一个软件实体应当尽可能少地与其他实体发生相互作用。
>
>

### 开放-闭合原则(OCP)

>软件实体（类、模块、函数）等应该是可以扩展的，但是不可以修改的。
>接受第一次被愚弄。

注： 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。
注： 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来的简单。

### 面向接口编程 

>接口是对象能响应的请求的集合 。
>面向接口编程可以被认为是面向抽象编程。
>契约是抽象的具体属性的体现。

### 反思

>设计模式在很多的时候其实都体现了语言的不足之处。
>在javascript中fn是可以被传递的，高阶函数是我们寻找出路的首选。
>在JavaScript中可以切换执行上下文。能很容易地实现方法委托的功能。
一种语言特性决定设计模式。
>目的（或者说是使用场景）决定了行为，对于不同的行为给出比较合理的方案。
>1 + 1 = 2 的概念。
>每种模式看起来差不多，但是模式之间的侧重点其实是不同的。
>一种场景可能可以用好几种模式实现，开始的时候先套一遍模式，中期需要了解模式的特点进行使用。
>根据使用场景取舍面向对象的原则，在具体的稳定性和方便性上进行取舍。

### 相关书籍阅读

JavaScript设计模式与开发实践  曾探